<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.3.3

<span id='note'>/**
</span>@class note
# gestion de la classe Note
*/


(function() {
  var async, helpers;

  async = require(&quot;async&quot;);

  helpers = require('../../client/app/helpers');

<span id='note-method-destroySome'>  /**
</span>  DestroyNote corresponding to given condition
  TODO optimise deletion : each deletion requires on request.
  */


  Note.destroySome = function(condition, callback) {
    var done, error, wait;
    wait = 0;
    error = null;
    done = function(err) {
      error = error || err;
      if (--wait === 0) {
        return callback(error);
      }
    };
    return Note.all(condition, function(err, data) {
      if (err) {
        return callback(err);
      }
      if (data.length === 0) {
        return callback(null);
      }
      wait = data.length;
      return data.forEach(function(obj) {
        return obj.destroy(done);
      });
    });
  };

<span id='note-method-destroyAll'>  /**
</span>  Delete all notes.
  */


  Note.destroyAll = function(callback) {
    return Note.destroySome({}, callback);
  };

<span id='note-method-allForPath'>  /**
</span>  Return notes which live under given path.
  */


  Note.allForPath = function(path, callback) {
    var regExp;
    regExp = helpers.getPathRegExp(path);
    return Note.all({
      where: {
        path: {
          regex: regExp
        }
      }
    }, callback);
  };

<span id='note-method-destroyForPath'>  /**
</span>  Destroy notes which live under given path.
  */


  Note.destroyForPath = function(path, callback) {
    var regExp;
    regExp = helpers.getPathRegExp(path);
    return Note.destroySome({
      where: {
        path: {
          regex: regExp
        }
      }
    }, callback);
  };

<span id='note-method-updatePath'>  /**
</span>  # Change path for every note which are children of given path to the 
  # new given one.
  # It is the result of moving notes inside tree.
  */


  Note.updatePath = function(path, newPath, newName, callback) {
    return Note.allForPath(path, function(err, notes) {
      var done, humanNames, nodeIndex, note, wait, _i, _len, _results;
      if (err) {
        return callback(err);
      }
      if (notes.length === 0) {
        return callback(new Error(&quot;No note for this path&quot;));
      }
      wait = notes.length;
      done = function(err) {
        var error;
        error = error || err;
        if (--wait === 0) {
          return callback(error);
        }
      };
      nodeIndex = path.split(&quot;/&quot;).length - 2;
      _results = [];
      for (_i = 0, _len = notes.length; _i &lt; _len; _i++) {
        note = notes[_i];
        note.path = newPath + note.path.substring(path.length);
        humanNames = note.humanPath.split(&quot;,&quot;);
        humanNames[nodeIndex] = newName;
        note.humanPath = humanNames;
        _results.push(note.save(done));
      }
      return _results;
    });
  };

<span id='note-method-movePath'>  /**
</span>  When a node is moved, all notes that are linked to this node are
  updated : sub-path are replaced by new node path.
  */


  Note.movePath = function(path, dest, humanDest, callback) {
    return Note.allForPath(path, function(err, notes) {
      var done, humanNames, i, nodeIndex, note, parentPath, pathLength, wait, _i, _j, _len, _ref, _results;
      if (err) {
        return callback(err);
      }
      if (notes.length === 0) {
        return callback(new Error(&quot;No note for this path&quot;));
      }
      wait = notes.length;
      done = function(err) {
        var error;
        error = error || err;
        if (--wait === 0) {
          return callback(error);
        }
      };
      parentPath = path.split(&quot;/&quot;);
      parentPath.pop();
      pathLength = parentPath.join(&quot;/&quot;).length;
      nodeIndex = parentPath.length - 1;
      _results = [];
      for (_i = 0, _len = notes.length; _i &lt; _len; _i++) {
        note = notes[_i];
        note.path = dest + note.path.substring(pathLength);
        humanNames = note.humanPath.split(&quot;,&quot;);
        for (i = _j = 0, _ref = nodeIndex - 1; 0 &lt;= _ref ? _j &lt;= _ref : _j &gt;= _ref; i = 0 &lt;= _ref ? ++_j : --_j) {
          humanNames.shift();
        }
        humanNames = humanDest.concat(humanNames);
        note.humanPath = humanNames;
        _results.push(note.save(done));
      }
      return _results;
    });
  };

}).call(this);
</pre>
</body>
</html>
